const audioContext = (function() {
	let context
	return () => context = context || new AudioContext()
}())

/** Known parameter sets */
export const WMS_PARAMS = [
	[0x40, 0x01, 0x00, 0x10, 0xE1, 0xFF, 0xFF, 0x0080],
	[0x28, 0x01, 0x00, 0x08, 0x81, 0xFF, 0xFF, 0x0200],
	[0x28, 0x81, 0x00, 0xFC, 0x01, 0xFC, 0xFF, 0x0200],
	[0xFF, 0x01, 0x00, 0x18, 0x41, 0x00, 0xFF, 0x0480],
	[0x00, 0xFF, 0x08, 0xFF, 0x68, 0x00, 0xFF, 0x0480]
]

/**
 * Find the matching parameter set index, otherwise returns -1
 * @param {number[]} params
 * @returns {number}
 */
export function paramSetIndex (params) {
	return WMS_PARAMS.findIndex(
		ps => ps.every((v, i) => v === params[i])
	)
}

export const WMS_LABELS = [
	'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'u1'
]

export function WmsWave(p) {
	const data = wmsByteToFloat(williams(...p))
	const buffer = createBufferFromData(data)
	let bs
	function play() {
		return new Promise(r => {
			bs = createBufferSource(buffer)
			bs.start()
			bs.addEventListener('ended', function cb() {
				bs && bs.removeEventListener('ended', cb)
				r()
			})
		})
	}
	function stop() {
		bs && bs.stop()
	}
	return {buffer, play, stop}
}

/** Sample rate generated by the function */
const WMS_SAMPLE_RATE = 894750
/** Max estimated size to alloc */
const WMS_MAX_SIZE = 5000000

////////////////////////////////////////////////////////////////////////
// Williams sound generation function adapted from here:
// http://www.lomont.org/Software/Misc/Robotron/
// This function reproduces an algorithm from the Williams Sound ROM, addresses 0xF503 to 0xF54F
// It takes 7 byte parameters and one 16-bit parameter, and returns a Uint8Array of sound values 0-255
// sampled at 894750 samples per second
function williams (
	// byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, ushort u1
	b1, b2, b3, b4, b5, b6, b7, u1
) {
	const b = new Uint8Array([b1, b2, b3, b4, b5, b6, b7]) // input values as bytes
	const u = new Uint16Array([u1])
	const c = new Uint8Array(2) // internal storage
	const count = new Uint16Array(1) // internal counter
	const sound = new Uint8Array(1) // current sound level
	const data = new Uint8Array(WMS_MAX_SIZE)
	let dataIndex = 0
	// copy the current sound value this many times into the output
	function dup (d) {
		while (d-- > 0) {
			data[dataIndex++] = sound[0]
		}
	}

	dup(8)
	sound[0] = b[6]
	do {
		dup(14)
		c[0] = b[0]
		c[1] = b[1]
		do {
			dup(4)
			count[0] = u[0]
			while (true) {
				dup(9)
				sound[0] = ~sound[0]

				const t1 = c[0] !== 0 ? c[0] : 256
				dup(Math.min(count[0], t1) * 14 - 6)
				if (count[0] <= t1) {
					break
				}
				dup(12)
				count[0] -= t1

				sound[0] = ~sound[0]

				const t2 = c[1] !== 0 ? c[1] : 256
				dup(Math.min(count[0], t2) * 14 - 3)
				if (count[0] <= t2) {
					break
				}
				dup(10)
				count[0] -= t2
			}

			dup(15)

			if (sound[0] < 128) {
				dup(2)
				sound[0] = ~sound[0]
			}

			dup(27)
			c[0] += b[2]
			c[1] += b[3]
		} while (c[1] !== b[4] && dataIndex < WMS_MAX_SIZE)

		dup(7)
		if (b[5] === 0) break
		dup(11)
		b[0] += b[5]
	} while (b[0] !== 0 && dataIndex < WMS_MAX_SIZE)

	console.log(`williams used ${dataIndex} bytes`)

	return dataIndex < WMS_MAX_SIZE ? data.subarray(0, dataIndex) : data
}

/**
 * Convert the byte output format from the williams function to a
 * buffer we can play.
 * Converts 8 bit uints to floats, scales sampleRate to audio default.
 * @param {Uint8Array} ba
 * @returns {Float32Array}
 */
function wmsByteToFloat (ba) {
	let scale = audioContext().sampleRate / WMS_SAMPLE_RATE
	if (scale > 1) {
		console.warn('Did not expect to upsample audio')
		scale = 1
	}
	const fa = new Float32Array(Math.floor(ba.length * scale))
	for (let i = 0; i < ba.length; ++i) {
		fa[Math.floor(i * scale)] = ba[i] / 128 - 1
	}
	return fa
}

/** @param {Float32Array} data */
function createBufferFromData (data) {
	const ac = audioContext()
	const b = ac.createBuffer(1, data.length, ac.sampleRate)
	b.getChannelData(0).set(data)
	return b
}

/** @param {AudioBuffer} b */
function createBufferSource (b) {
	const ac = audioContext()
	const bs = ac.createBufferSource()
	bs.buffer = b
	bs.connect(ac.destination)
	return bs
}
